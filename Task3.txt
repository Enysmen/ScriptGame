Используя язык по вашему выбору — из набора C#/JavaScript/TypeScript/Java/PHP/Ruby/Python/Rust, пожалуйста — напишите консольный скрипт, реализующий обобщенную нетранзитивную игру в кости (с поддержкой произвольных значений на костях). Конечно, рекомендуется использовать язык вашей «специализации», то есть C# или JavaScript/TypeScript или PHP, но это не обязательно.

При запуске с параметрами командной строки — аргументами метода main или Main в случае Java или C# соответственно, sys.argv в Python, process.argv в Node.js и т. д. — он принимает 3 или более строк, каждая из которых содержит 6 целых чисел, разделенных запятыми. Например, python game.py 2,2,4,4,9,9 6,8,1,1,8,6 7,5,3,7,5,3.

Если аргументы неверны, необходимо вывести аккуратное сообщение об ошибке, а не трассировку стека — что именно не так и пример того, как это сделать правильно (например, пользователь указал только две игральные кости или вообще не указал ни одной, использовал нецелые числа и т. д.). Все сообщения должны быть на английском языке.


Важно: конфигурация кубиков передается как аргументы командной строки; вы не «анализируете» ее из входного потока.

Победа определяется следующим образом: компьютер и пользователь выбирают разные кубики, выполняют свои «броски», и тот, у кого результат выше, побеждает.

Первый шаг игры — определить, кто делает первый ход. Вы должны доказать пользователю, что выбор честный (недостаточно сгенерировать случайный бит 0 или 1; пользователю нужно доказательство честной игры).

Когда пользователи делают бросок, они выбирают кубики с помощью «меню» CLI и «генерируют» случайное значение с помощью компьютера. Опции состоят из всех доступных кубиков, опции выхода (отмены) и опции справки.

Когда компьютер делает бросок, он выбирает кубики и «генерирует» случайное значение.

Конечно, «случайная» генерация также должна быть доказуемо честной.
Обратите внимание, что задача не «Реализовать какую-то игру в кубики». Вам необходимо реализовать все указанные требования, включая справедливую случайную генерацию, настраиваемые игральные кости, классы с ограниченными обязанностями и т. д.

Для решения этой задачи недостаточно просто скопировать требования в какой-то инструмент ИИ и скопировать код (по крайней мере, сегодня). Конечно, нет ничего плохого в использовании любого инструмента, пока вы получаете правильно работающий результат, но я должен предостеречь вас от попыток представить что-то лишь отдаленно связанное с игрой в кости, но не связанное с указанными требованиями. Лучше сделать меньше, но понимать, что именно вы реализовали.
Итак, вам нужно реализовать доказуемую «честную» генерацию случайных целых чисел (других от 0 до 1 или от 0 до 5).

Для генерации такого значения компьютер генерирует одноразовый криптографически безопасный случайный ключ (используя соответствующий API, такой как SecureRandom, RandomNumberGenerator и т. д. — это обязательно) длиной не менее 256 бит.

Затем компьютер генерирует равномерно распределенное целое число в требуемом диапазоне (используя безопасное случайное число; обратите внимание, что оператора % недостаточно для получения равномерного распределения) и вычисляет HMAC (на основе SHA3) из сгенерированных целых чисел в виде сообщения со сгенерированным секретным ключом. Затем компьютер отображает HMAC пользователю.

После этого пользователь выбирает целое число в том же диапазоне. Полученное значение вычисляется как сумма номера пользователя и номера компьютера с использованием модульной арифметики. Когда компьютер отображает результат, он также отображает использованные секретные ключи.



Перечитайте абзац выше; последовательность имеет решающее значение (делать это по-другому, например, показывать ключ перед выбором пользователем номера или отображать HMAC второй раз вместо ключа и т. д., просто не имеет смысла).

Обратите внимание, что «честная случайная генерация» требует участия обеих сторон, пользователя и компьютера; просто сгенерировать случайное число и вывести его недостаточно.

Таким образом, пользователь может проверить, что компьютер не жульничает (конечно, компьютер все равно может попытаться жульничать, но пользователь может этому противодействовать).

При выборе опции «помощь» в терминале вам необходимо отобразить таблицу (использовать ASCII-графику), которая показывает вероятности выигрыша для каждой пары костей.
Генерация таблицы должна быть в отдельном классе. Расчет вероятности должен быть в отдельном классе. Реализация «протокола» честной генерации чисел должна быть в отдельном классе. Генерация случайного ключа/числа и расчет HMAC должны быть в отдельном классе. Анализ конфигурации костей должен быть в отдельном классе. Абстракция игральных костей должна быть в отдельном классе. Как правило, ваш код должен состоять как минимум из 6-9 классов.

Вам следует максимально использовать библиотеки основных классов и сторонние библиотеки, а не изобретать велосипед.



КОЛИЧЕСТВО КОСТЕЙ МОЖЕТ БЫТЬ ПРОИЗВОЛЬНЫМ (> 2).
Пример (конечно, Java используется только в качестве примера, вы будете использовать язык вашей группы):

> java -jar game.jar 2,2,4,4,9,9 6,8,1,1,8,6 7,5,3,7,5,3
Let's determine who makes the first move.
I selected a random value in the range 0..1 (HMAC=C8E79615E637E6B14DDACA2309069A76D0882A4DD8102D9DEAD3FD6AC4AE289A).
Try to guess my selection.
0 - 0
1 - 1
X - exit
? - help
Your selection: 0
My selection: 1 (KEY=BD9BE48334BB9C5EC263953DA54727F707E95544739FCE7359C267E734E380A2).
I make the first move and choose the [6,8,1,1,8,6] dice.
Choose your dice:
0 - 2,2,4,4,9,9 
1 - 7,5,3,7,5,3
X - exit
? - help
Your selection: 0 
You choose the [2,2,4,4,9,9] dice.
It's time for my throw.
I selected a random value in the range 0..5 (HMAC=AA29E7275FE17A8D1184E2D4B6B0F46D815224270C94907CF007F2118CF400F7).
Add your number modulo 6.
0 - 0
1 - 1
2 - 2
3 - 3
4 - 4
5 - 5
X - exit
? - help
Your selection: 4
My number is 3 (KEY=7329ABD54A1633D2079EA7A48B401018D7EE6DD4C130AB5C31BC029CC8359637).
The result is 3 + 4 = 1 (mod 6).
My throw is 8.
It's time for your throw.
I selected a random value in the range 0..5 (HMAC=652863C27870CCA331458F4658D89413F405736FE5AA19B868FBDDAB5611A406).
Add your number modulo 6.
0 - 0
1 - 1
2 - 2
3 - 3
4 - 4
5 - 5
X - exit
? - help
Your selection: 5
My number is 0 (KEY=92564A82A515DEBC3FE9842D20DCEA3F3AAFB2080314A09A1E9A2CC729EDAF44).
The result is 0 + 5 = 5 (mod 6).
Your throw is 9.
You win (9 > 8)!







Обратите внимание, что второй игрок (пользователь или компьютер, в зависимости от того, угадал ли пользователь выбор компьютера 0/1 или нет) не может выбрать кости, выбранные первым игроком (компьютером или пользователем).
Первое «честное поколение» (0 или 1) должно определить, кто первым выбирает кости. Соперники выбирают разные кости и после этого выполняют свои броски (на самом деле, порядок бросков не должен иметь значения, поскольку они используют разные кости). Конечно, броски и компьютера, и пользователя должны быть «честными» (использовать «ввод» с обеих сторон).
Чтобы отправить решение, вам необходимо отправить электронное письмо на адрес p.lebedev@itransition.com со следующим:



ссылка на видео, демонстрирующее запуск с разными параметрами (4 одинаковых кубика 1,2,3,4,5,6 1,2,3,4,5,6 1,2,3,4,5,6 1,2,3,4,5,6 а также 3 кубика 2,2,4,4,9,9 1,1,6,6,8,8 3,3,5,5,7,7), запуск с неверными параметрами (нет кубика; 2 кубика; неверное количество граней; нецелое значение в конфигурации кубика), справочная таблица с вероятностями (на 3 кубиках из примера), вся сыгранная игра с выводом результатов (не менее 2 запусков);
ссылка на публичный репозиторий Github.

Сделайте видео общедоступным. Не пытайтесь поделиться своим видео с помощью моей рабочей электронной почты или чего-то еще. Сделайте свое видео общедоступным. Не озвучивайте, без звука.

Откройте терминал на весь экран во время записи.



И в качестве пояснения: при вычислении HMAC ключом является тот же секретный ключ, который вы сгенерировали. А сообщение — это число. Получив ключ, пользователь сможет вычислить HMAC и сравнить его с показанным ранее HMAC. Это не очень сложно. 🙂

Каждый «честный случай» зависит от чисел, сгенерированных обоими игроками (человеком и компьютером). HMAC используется для доказательства того, что компьютер не изменил свой номер после того, как пользователь сделал выбор.

Распространенная ошибка — пытаться придумать свой «HMAC» как хэш случайного «ключа». Это не сработает. Если вы покажете одни и те же строки до выбора пользователя и после выбора пользователя, пользователь не получит новой информации, и, соответственно, вы ему ничего не докажете. Необходимо сгенерировать ключ (с помощью безопасного генератора), сгенерировать компьютерное значение, вычислить HMAC (по стандартному алгоритму) из компьютерного значения (сообщения) и ключа (ключа), показать HMAC, получить пользовательское значение, вычислить результат и показать ключ. Перечитайте этот абзац до полного понимания.
Для чего это задание?



Вам нужно научиться читать и понимать требования, немного глубже разобраться в хэш-функциях, понять, для чего они нужны, знать концепцию HMAC, научиться думать о том, как точная последовательность шагов может дать вам некое доказательство или контракт, работать с внешними библиотеками, затронуть некоторые основы ООП и еще несколько вещей.


Обратите внимание, что «честная» процедура генерирует индекс грани кубика, а не «результат броска». Пользователи могут указать любой порядок значений граней при запуске приложения.

Иногда слов недостаточно, поэтому вот диаграмма для совместной генерации случайных чисел в диапазоне от 0 до 5 включительно для ЗАДАЧИ №3.


+---+---------------------------+---------------------+
| # | Computer                  | User                |
+---+---------------------------+---------------------+
| 1 | Generates a random number |                     |
|   | `x ∈ {0,1,2,3,4,5}`       |                     |
+---+---------------------------+---------------------+
| 2 | Generates a secret key    |                     |
+---+---------------------------+---------------------+
| 3 | Calculates and displays   |                     |
|   | `HMAC(key).calculate(x)`  |                     |
+---+---------------------------+---------------------+
| 4 |                           | Selects a number    |
|   |                           | `y ∈ {0,1,2,3,4,5}` |
+---+---------------------------+---------------------+
| 5 | Calculates the result     |                     |
|   | `(x + y) % 6`             |                     |
+---+---------------------------+---------------------+
| 6 | Shows both the result     |                     |
|   | and the key               |                     |
+---+---------------------------+---------------------+







Как улучшить удобство использования таблицы справки консоли (сделать ее более понятной).
Во-первых, вы можете выделить строку заголовка. Например, использовать какой-то цвет.
Во-вторых, вы заполняете заголовки соответствующим содержимым, например:



Probability of the win fоr the user:
+-------------+-------------+-------------+-------------+
| User dice v | 2,2,4,4,9,9 | 1,1,6,6,8,8 | 3,3,5,5,7,7 |
+-------------+-------------+-------------+-------------+
| 2,2,4,4,9,9 | - (0.3333)  | 0.5556      | 0.4444      |
+-------------+-------------+-------------+-------------+
| 1,1,6,6,8,8 | 0.4444      | - (0.3333)  | 0.5556      |
+-------------+-------------+-------------+-------------+
| 3,3,5,5,7,7 | 0.5556      | 0.4444      | - (0.3333)  |
+-------------+-------------+-------------+-------------+








784 / 5 000
Пожалуйста, помните, что целые числа могут быть больше 9, поэтому вы не можете заранее определить ширину столбцов. В любом случае, вам придется использовать стороннюю библиотеку для вывода таблицы. Диагонали отформатированы по-другому, потому что кубик не может играть сам с собой, но можно вычислить вероятность; вы можете просто вывести — или только вероятность, если хотите.

И последнее, но не менее важное: вы можете добавить какой-нибудь текст перед таблицей (например, чтобы помочь понять правила игры).

Конечно, для большого количества кубиков было бы неплохо реализовать какую-то пагинацию, но это выходит за рамки базовой задачи (вы можете рассматривать это как необязательную задачу «для высшего класса»).
😅
Вот и все — какая-нибудь диаграмма последовательности, пример вывода, пояснения... Прочитайте все как минимум дважды.

















